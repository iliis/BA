\chapter{Optimizations and other improvements}
\label{sec:optimizations}

The algorithm described in the previous section works well but suffers from
slow performance and does not nearly run in realtime on an embedded device.
Therefore, some optimization strategies are applied:

\section{Image pyramids}
\label{sec:pyramids}

A common optimization technique is the use of multiple resolutions: Images are
repeatedly downscaled by a factor of two (essentially quartering the number of
pixels) by averaging over a 2 x 2 block to generate a stack of increasingly
smaller images (a 'pyramid').

The minimization is run on the smallest set of images and the resulting value
is used as an initial value for the next bigger set of images.

This greatly reduces the number of iterations required and enhances the
convergence radius.

The image pyramid can also be used to trade a bit of accuracy for even more
performance gain by simply aborting early and not using the full resolution at
all. Throwing out the one or two uppermost levels usually incurs negligible
loss of accuracy. See also section~\ref{sec:results_qualitative}.


\section{Pixel selection by image gradient}
\label{sec:gradient_filtering}

We can further optimize away pixels which do not strongly influence the
minimization such as points in homogenous image regions where $\nabla
\mathbf{I} \approx 0$ and therefore $\mat{J_I} \approx 0$.

This is already provided to some extent by the semi-global matching alorithm,
as pixels without strong gradients are usally hard to match and therefore often
don't provide a disparity value.

\section{Handling outliers}

By robustly weighting the photometric error terms outliers can be dampened to
reduce the influence of occlusions, moving scenery or other noise, such as
errors from the semi-global matcher. This improves quality and stability with
negligible performance penalty.

Another idea (which wasn't fully investigated) to handle occlusions is to use a
Z-buffer to eliminate points which are behind others when warped.


\section{Further possible optmiziations}

A few things which have not been investigated in this work but which provide
good avenues for further optimizations:

\subsection{integration of IMU}

Modern visual odometry and SLAM systems such as \cite{leutenegger2013keyframe}
incorporate data from an inertial measurement unit using various complicated
filtering schemes to increase accuracy.

In contrast, using integrated acceleration values for pohotometric odometry
would be trivial by providing a good initial guess for the minimization process
and could greatly speed up perfomance by reducing the number of required
optimization iterations.

\subsection{Keyframes}

Instead of matching the previous frame, keyframes can be used which are only
updated when the relative motion gets too big. This way, drift can be reduced
and even completely eliminated when being more or less stationary.

\subsection{Offload more work to FPGA}

Large parts of the photometric odometry algorithm are highly parallelizable and
would profit from an implementation running on the FPGA. This is the main point
of this work and is further discussed in section~\ref{sec:timing}.



